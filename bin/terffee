#!/usr/bin/env coffee
#============================================================================
# CoffeeScriptのソースファイルと保存先を指定し、コンパイル＆minify化を行う
# 「-c」オプションでソースファイルだけを指定した場合は、生成されるファイル
# はソースファイルと同じ場所に保存される。
# 例）terffee -c hoge.coffee
#
# 「-o」オプションで保存先を指定する。
# 保存場所の最後をスラッシュにするか、すでに存在するディレクトリ名を指定し
# た場合は、ディレクトリとみなしその中に生成したファイルが「.min.js」の拡
# 張子で保存される。
# 例）terffee -c hoge.coffee -o ./apps/js/ → ./apps/js/hoge.min.jsが生成される
#
# 最後がスラッシュではない場合は、指定したソースファイルのコンパイル＆minify
# されたものがひとつのファイルとして保存される。
# 例）terffee -c hoge.coffee -c foo.coffee -o hogefoo.min.js
#
# ソースファイルと保存場所の対応は、記述した順番になる。
# 保存先の数がソースファイルの数よりも少ない場合、足りない分は最後の保存場所
# がそのまま使われる。
# 例）terffee -c hoge.coffee -o hoge.min.js -c foo.coffee -o foo.min.js -c bar.coffee
# （上記の例では、「bar.coffee」は「foo.min.js」に結合される）
#
# type： -1 指定したpathが存在しない
#         0
#         1 ディレクトリ
#         2 ファイル　
#============================================================================

TERSER = require("terser")
COFFEE = require("coffee-compiler")
CHOKIDAR = require("chokidar")
ARGV = require("argv")
MINIMIST = require("minimist")
ASYNC = require("async")
FS = require("fs-extra")
PATH = require("path")
PROMISE = require("bluebird")
FORM = require("ndlog").form

echo = require("ndlog").echo

#============================================================================
# CoffeeScriptをコンパイルし、minify化する
#============================================================================
compile = (fpath) ->
  return new PROMISE (resolve, reject) ->
    COFFEE_OPTS =
      sourceMap: true
      bare: true
    COFFEE.fromFile fpath, COFFEE_OPTS, (err, jsstr) ->
      #echo(jsstr)
      if (err)
        reject(-1)
      else
        code = (TERSER.minify(jsstr)).code
        resolve(code)

#============================================================================
# 保存先として指定された場所／ファイルをチェックする
#============================================================================
path_check = (path) ->
  #echo("path=%@", path)
  if (path.match(/\/$/))
    # pathがスラッシュで終わっている
    type = 1 # ディレクトリ
    fname = undefined
  else
    # pathがスラッシュで終わっていない
    try
      # pathが既存ディレクトリ
      if (FS.statSync(path).isDirectory())
        type = 1 # ディレクトリ
        fname = undefined
      else
        type = 2 # ファイル
        fname = PATH.basename("./#{path}")
    catch e
      # pathが存在しない
      #echo(e)
      type = -1 # 存在しない
      fname = undefined

  return
    type: type
    fname: fname

#============================================================================
# メイン処理
#============================================================================

# 引数チェック
ARGV.option
  name: "watch"
  short: "w"
  type: "string"
  description: "watch source file change."
  example: "terffee -wc [source file path]"
ARGV.option
  name: "compile"
  short: "c"
  type: "path"
  description: "compile source file."
  example: "terffee -c [source file path]"
ARGV.option
  name: "output"
  short: "o"
  type: "path"
  description: "compiled file output directory."
  example: "terffee -o [output directroy]"
argopt = ARGV.run()

target = process.argv
target.splice(0, 2)
argm = MINIMIST(target)
#echo(argm)

#============================================================================
# コンパイルするソースファイル一覧を取得する
#============================================================================
sourcepath_tmp = []
directotypath = []
sourcepath_tmp = argm._
c_opt = argm.c || argm.compile
#echo(c_opt)
if (c_opt?)
  if (typeof c_opt == 'string')
    c_opt = [c_opt]
  #c_opt.push.apply(c_opt, argm._)
  sourcepath_tmp.push.apply(sourcepath_tmp, c_opt)
#echo(sourcepath_tmp)

#============================================================================
# コンパイル／minify化したファイルを保存する一覧を取得する　
#============================================================================
outputlist_tmp = argm.o || argm.output
if (typeof outputlist_tmp == "object")
  outputlist = outputlist_tmp
else
  outputlist = [outputlist_tmp]

#============================================================================
# 引数で指定されたソース一覧と保存先一覧を整理する
#============================================================================
#echo(outputlist)
sourcepath_tmp.map (fpath, cnt) ->
  #echo("fpath=%@", fpath)

  #===========================================================================
  # ソースの種類（ファイルかディレクトリか）と存在するかチェック
  #===========================================================================
  # 処理するファイル
  src = fpath
  #echo("src=%@", src)
  stype = path_check(src).type
  # ソースに指定されたファイル／ディレクトリが存在する場合は処理する
  if (stype > 0)
    # 保存先リストからひとつ取り出す
    output = outputlist[cnt] || outputlist[outputlist.length-1]

    # 保存先がundefined
    if (!output?)
      # 保存先が無い場合は、保存先をsrcから生成する
      otype = 1
      if (FS.statSync(src).isDirectory())
        # srcがディレクトリだった
        output = src
      else
        # srcがファイルだった
        output = PATH.dirname(src)

    else
      # 保存先が存在する
      otype = path_check(output).type
      # outputが存在しなかったらファイル
      if (otype == -1)
        otype = 2

    # srcの末尾に「/」があったら除去する
    src = src.replace(/\/*$/, "")
    # outputの末尾に「/」があったら除去する
    output = output.replace(/\/*$/, "")

    sourcepath_tmp.push
      src: src
      stype: stype
      output: output
      otype: otype

    #echo("src=[%@], stype=%@, output=[%@], otype=%@", src, stype, output, otype)

#echo(sourcepath_tmp)

#============================================================================
# ソースファイルが指定されていない
#============================================================================
if (target.length == 0)
  ARGV.run(["-h"])
  process.exit(1)

#process.exit(0)

if (argm.w || argm.watch)

  #==========================================================================
  # ソースファイル／ディレクトリ監視
  #==========================================================================
  watchlist = []
  for fn in sourcepath_tmp
    fn = fn.replace(/\/*$/, "")
    echo("fn=%@", fn)
    watchlist[watchlist.length] = CHOKIDAR.watch(fn)
    #persistent: true

    try
      # check compile target
      FS.accessSync(fn, FS.F_OK)
      watchlist[watchlist.length-1].on 'change', (fpath, stats) ->
        fname = PATH.basename(fpath)
        if (PATH.extname(fname) == ".coffee")
          echo("fname=%@", PATH.extname(fname))
          console.log("compile and minify: [#{fname}]")
        #compile(fpath).then (code) ->
        #  console.log(code)
        #.catch (e) ->
        #  console.log(e)
      .on 'add', (fpath, stats) ->
        fname = PATH.basename(fpath)
        if (PATH.extname(fname) == ".coffee")
          console.log("watching file: [#{fname}]")
        #compile(fpath).then (code) ->
        #  console.log(code)
        #.catch (e) ->
        #  console.log(e)
      .on 'unlink', (fpath, stats) ->
        fname = PATH.basename(fpath)
        if (PATH.extname(fname) == ".coffee")
          console.log("delete file: [#{fname}]")
    catch e
      # target is not accessible
else

  #process.exit(0)

  #==========================================================================
  # ソースファイルコンパイル
  #==========================================================================
  # ソース指定がディレクトリの場合を想定して展開する
  sourcepath = []
  for srcinfo in sourcepath_tmp
    src = srcinfo.src
    output = srcinfo.output
    stype = srcinfo.stype
    otype = srcinfo.otype

    if (stype == 1) # ディレクトリ
      files = FS.readdirSync(src)
      for srcfname in files
        srcfullpath = FORM("%@/%@", src, srcfname)
        if (!srcfname.match(/\.coffee$/) || FS.statSync(srcfullpath).isDirectory())
          continue
        switch (otype)
          when 1 # 出力先がディレクトリ　
            ofile = "#{output}/"+PATH.basename(srcfname).replace(/\.coffee$/, ".min.js")
          when 2 # 出力先がファイル　
            ofile = output
        #echo "srcfname=%@, ofile=%@", srcfname, ofile
        sourcepath.push
          src: srcfullpath
          output: ofile
    else if (stype == 2) # ファイル
      if (!src.match(/\.coffee$/))
        continue
      ofile = "#{output}/"+PATH.basename(src).replace(/\.coffee$/, ".min.js")
      sourcepath.push
        src: src
        output: ofile

  echo sourcepath

  # 保存先にファイルを指定しても、それがディレクトリ名として生成されてその中にmin.jsを書き出してしまう



  createFileFlagTable = {}
  ASYNC.whilst ->
    # コンパイルするソースファイルがなくなったらループを抜ける
    if (sourcepath.length > 0)
      return true
    else
      return false

  , (callback) ->
    # ファイルパスをひとつ取り出す
    srcinfo = sourcepath.shift()
    src = srcinfo.src
    output = srcinfo.output

    compile(src).then (code) ->
      if (createFileFlagTable[src.toString]?)
        FS.appendFile(output, code, 'utf8')
        #echo code.replace(/\r?\n$/, "")
      else
        FS.outputFile(output, code, 'utf8')
        #echo code.replace(/\r?\n$/, "")
    .then (err) ->
      createFileFlagTable[src.toString] = true
      if (err)
        callback(-1, null)
      else
        callback(null, 1)
    .catch (err) ->
      callback(-1, null)

  , (err, result) ->
    if (err)
      switch (err)
        when -1
          console.log("compile error.")
    process.exit(0)


